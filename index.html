<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="style.css">
        <script src="js/utils.js"></script>
        <script src="js/ModelHelper.js"></script>
        <script type="module">
            import Shaders from "./shaders/module.js"
            import Engine  from "./js/engine/engine.js"
            import Shapes  from "./ressources/shapes/module.js"
            document.Shaders = Shaders
            document.Engine  = Engine
            document.Shapes  = Shapes
        </script>
    </head>
    <body onload="init();start()">
        <div>
            <div id="parameters" class="panel"></div>
            <div id="debug_panel" class="panel">
                <details>
                    <summary><h2>Debug</h2></summary>
                    <table>
                        <tr><td>FPS : </td><td id="fps"></td></tr>
                        <tr><td>Refresh rate : </td><td id="refresh_rate"></td></tr>
                    </table>
                    <input onchange="params.depth_test=this.checked;restart()" id="depth_test" type="checkbox" checked/><label>Enable depth testing</label>
                    <input onchange="params.show_shadow_map=this.checked;restart()" id="show_shadow_map" type="checkbox" unchecked/><label>Show shadow map</label>
                    <br>
                    <label>Depth test function</label>
                    <select onchange="restart()" id="depth_func">
                        <option value="NEVER">Never</option>
                        <option value="ALWAYS">Always</option>
                        <option value="LESS">Less</option>
                        <option value="EQUAL">Equal</option>
                        <option value="LEQUAL" selected="selected">Less or equal</option>
                        <option value="GREATER">Greater</option>
                        <option value="GEQUAL">Greater or equal</option>
                        <option value="NOTEQUAL">Not equal</option>
                    </select>
                    <div id="projection_matrix"></div>
                    <div id="view_matrix"></div>
                </details>
            </div>
        </div>
        <canvas id="canvas" width="800" height="800"></canvas>
    </body>    
    <script>
        function init(){
            let lightsContent = (
                generateSliders("AL",  ["R","G","B"], 0,   1,   "Ambiant light color") +
                generateSliders("DL",  ["R","G","B"], 0,   1,   "Directional light color") +
                generateSliders("DL",  ["X","Y","Z"], -1,  1,   "Directional light direction") +
                generateSliders("PL",  ["R","G","B"], 0,   1,   "Point light color") +
                generateSliders("PL",  ["X","Y","Z"], -10, 10,  "Point light position") +
                generateSliders("CL",  ["R","G","B"], 0,   1,   "Cone light color") +
                generateSliders("CL",  ["X","Y","Z"], -10, 10,  "Cone light position") +
                generateSliders("CLD", ["X","Y","Z"], -180,   180, "Cone light direction")
            )

            getById("parameters").innerHTML = generateTabs("mainTab", [
                ["View", ""], ["Lights", lightsContent], ["Objects", ""], ["Shaders", ""]
            ])

            Shaders        = document.Shaders
            Shapes         = document.Shapes
            Engine         = document.Engine
            updateInterval = 30
            previousTime   = 0
            frameNumber    = 0
            engine         = null
            needRestart    = false
            light_marker   = null
            params         = {}
        }

        function getAmbiantLightColor(){ return [getValue("ALR"), getValue("ALG"), getValue("ALB")] }
        function getDirLightColor(){ return [getValue("DLR"), getValue("DLG"), getValue("DLB")] }
        function getDirLightPos(){ return [getValue("DLX"), getValue("DLY"), getValue("DLZ")] }
        function getPointLightColor(){ return [getValue("PLR"), getValue("PLG"), getValue("PLB")] }
        function getPointLightPos(){ return [getValue("PLX"), getValue("PLY"), getValue("PLZ")] }
        function getConeLightColor(){ return [getValue("CLR"), getValue("CLG"), getValue("CLB")] }
        function getConeLightPos(){ return [getValue("CLX"), getValue("CLY"), getValue("CLZ")] }
        function getConeLightDir(){ return [getValue("CLDX"), getValue("CLDY"), getValue("CLDZ")] }
        function getDepthFunction(){
            switch(getValue("depth_func")){
                case "NEVER"    : return WebGL2RenderingContext.NEVER 
                case "ALWAYS"   : return WebGL2RenderingContext.ALWAYS 
                case "LESS"     : return WebGL2RenderingContext.LESS 
                case "EQUAL"    : return WebGL2RenderingContext.EQUAL 
                case "LEQUAL"   : return WebGL2RenderingContext.LEQUAL 
                case "GREATER"  : return WebGL2RenderingContext.GREATER 
                case "GEQUAL"   : return WebGL2RenderingContext.GEQUAL 
                case "NOTEQUAL" : return WebGL2RenderingContext.NOTEQUAL 
            }
        }

        function restart(){
            console.log("Restarting...")
            needRestart = true
        }

        function start(){
            needRestart = false
            params.depth_test_function = getDepthFunction()

            engine = new Engine(getById("canvas"), Shaders.blinnPhongShadowmap, Shaders.shadowMap, params)
            engine.addObject(Shapes.Plane, "Ground")
            engine.addObject(Shapes.Cube, "Cube_1", [0,2,1])
            engine.addObject(Shapes.Cube, "Cube_2", [2,0,1])
            engine.addObject(Shapes.Cube, "Cube_3", [0,-2,2])
            engine.addObject(Shapes.Cube, "Cube_4", [-2,0,1])
            ModelHelper.loadWavefront("dragon/dragon.obj", "").then(obj => engine.addObject(obj, "Dragon"))
            ModelHelper.loadWavefront("gizmo/gizmo.obj", "").then(obj => engine.addObject(obj, "Gizmo"))
            engine.addObject(Shapes.LightMarker, "Light_marker", [0,0,0])

            engine.setCubemap("ressources/cubemaps/field_sunset")
            engine.setSkybox(Shaders.skybox, "ressources/cubemaps/field_sunset")

            generateObjectsTab(engine.objects.list)
            generateViewTab(engine)
            updateView(true)

            render(0)
        }

        function render(currentTime) {
            frameNumber++
            const deltaTime = currentTime - previousTime
            previousTime = currentTime

            if(frameNumber % updateInterval == 0){
                getById("fps").innerHTML = Math.round(1000/deltaTime)
                getById("refresh_rate").innerHTML = Math.round(deltaTime)+" ms"
            }

            engine.scene.lights.setAmbient(getAmbiantLightColor())
            engine.scene.lights.setDirectional(getDirLightColor(), getDirLightPos())
            engine.scene.lights.setPoint(getPointLightColor(), getPointLightPos())
            engine.scene.lights.setCone(getConeLightColor(), getConeLightPos(), getConeLightDir())
            engine.setObjectTransform("Light_marker", getConeLightPos())

            engine.render()
            needRestart ? start() : requestAnimationFrame(render)
        }

        function updateView(fromSliders){
            if(fromSliders){
                engine.scene.camera.setView(...getTransformSlidersValues("view"))
                setMatrixValues("view", engine.getViewProjection().view)
            }else{
                const values = getMatrixValues("view")
                console.log(values)
                engine.gl.useProgram(engine.program)
                engine.scene.camera.view = values
                engine.setViewProjection(values)
            }
        }
        function generateViewTab(engine){
            getById("mainTab_View").innerHTML = (
                generateTransformSliders("view", "updateView(true)", [[0,0,-26],[-71,0,-120],[1,1,1]]) +
                generateMatrix("view", `updateView(false)`, engine.getViewProjection().view) 
            )
        }

        function updateObject(obj_name, fromSliders){
            if(fromSliders){
                let obj_found = null 
                Object.values(engine.objects).forEach(obj => {
                    if(obj.name == obj_name) {
                        obj_found = obj
                        engine.setObjectTransform(obj, ...getTransformSlidersValues(obj_name))
                    }
                })
                setMatrixValues(obj_name, obj_found.modelMatrix)
            }else{
                let values = getMatrixValues(obj_name)
                Object.values(engine.objects).forEach(obj => {
                    if(obj.name == obj_name) {
                        obj.modelMatrix = values
                    }
                })
            }
        }
        function generateObjectsTab(objs){
            let names_content = []
            Object.values(objs).forEach( (obj, i) => {
                let content = `Number of triangles : ${obj.count}<div id="objects_details_${i}_matrix"></div>`
                content += generateTransformSliders(obj.name, `updateObject('${obj.name}', true)`)
                content += generateMatrix(obj.name, `updateObject('${obj.name}', false)`, obj.modelMatrix)
                names_content.push([obj.name, content])
            })
            getById("mainTab_Objects").innerHTML = generateTabs("objectsTab", names_content)
        }
    </script>  
</html>