<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="style.css">
        <script src="js/utils.js"></script>
        <script src="js/ModelHelper.js"></script>
        <script type="module">
            import Shaders from "./shaders/module.js"
            import Engine  from "./js/engine/engine.js"
            import Shapes  from "./ressources/shapes/module.js"
            document.Shaders = Shaders
            document.Engine  = Engine
            document.Shapes  = Shapes
        </script>
    </head>
    <body onload="init();start()">
        <h1 class="main_title">Tiny WebGL Engine</h1>
        <p class="subtitle">Simple 3D engine build in WebGL from scratch</p>
        <hr>
        <br>
        <div id="main_content">
            <div>
                <div id="parameters" class="panel"></div>
                <div id="debug_panel" class="panel">
                    <details>
                        <summary>Parameters</summary>
                        <table>
                            <tr><td>FPS : </td><td id="fps"></td></tr>
                            <tr><td>Refresh rate : </td><td id="refresh_rate"></td></tr>
                        </table>
                        <input onchange="params.depth_test=this.checked;restart()" id="depth_test" type="checkbox" checked/><label>Enable depth testing</label>
                        <br>
                        <input onchange="params.show_shadow_map=this.checked;restart()" id="show_shadow_map" type="checkbox" unchecked/><label>Show shadow map</label>
                        <br>
                        <label>Depth test function</label>
                        <select onchange="restart()" id="depth_func">
                            <option value="NEVER">Never</option>
                            <option value="ALWAYS">Always</option>
                            <option value="LESS">Less</option>
                            <option value="EQUAL">Equal</option>
                            <option value="LEQUAL" selected="selected">Less or equal</option>
                            <option value="GREATER">Greater</option>
                            <option value="GEQUAL">Greater or equal</option>
                            <option value="NOTEQUAL">Not equal</option>
                        </select>
                        <br>
                        <label>Skybox</label><select id="skybox_select" onchange="skybox=this.value;restart()">
                            <option value="null">None</option>
                            <option value="debug">Debug</option>
                            <option value="field_sunset" selected="selected">Sunset field</option>
                            <option value="underground">Underground</option>
                        </select>
                    </details>
                </div>
            </div>
            <canvas id="canvas" width="800" height="800"></canvas>
        </div>
        <hr>
        <div class="explanations">
            <p>
                This 3D model viewer is built from scratch in WebGL2. <br>
                It is for now very limited, but has the following graphics properties :
            </p>
                <ul>
                    <li>One ambient light</li>
                    <li>One directional light, casting no shadows</li>
                    <li>One point light, casting omnidirectional shadows and specular</li>
                    <li>One cone light, casting directional shadows in orthographic perspective</li>
                    <li>A skybox</li>
                    <li>Textures, for now only one for the whole scene</li>
                    <li>Reflective material, reflecting the skybox only (for now !)</li>
                    <li>A few models, with parameters to change their transform</li>
                </ul>
            <p>
                Some features are still lacking, and some combinations of parameters can produce unrealistic-looking scenes.
            </p>
        </div>
    </body>    
    <script>
        function init(){
            let lightsContent = (
                generateSliders("AL",  ["R","G","B"], 0,   1,   "Ambiant light color",        [0,0,0]) +
                generateSliders("DL",  ["R","G","B"], 0,   1,   "Directional light color",    [0,0,0]) +
                generateSliders("DL",  ["X","Y","Z"], -1,  1,   "Directional light direction") +
                generateSliders("PL",  ["R","G","B"], 0,   1,   "Point light color",          [0,0,0]) +
                generateSliders("PL",  ["X","Y","Z"], -10, 10,  "Point light position",       [6.8, 10, 9]) +
                generateSliders("CL",  ["R","G","B"], 0,   1,   "Cone light color") +
                generateSliders("CL",  ["X","Y","Z"], -10, 10,  "Cone light position",        [6.8, 10, 9]) +
                generateSliders("CLD", ["X","Y","Z"], -180,   180, "Cone light direction",    [-63, 10, 0])
            )

            getById("parameters").innerHTML = generateTabs("mainTab", [
                ["View", ""], ["Lights", lightsContent], ["Objects", ""], ["Shaders", ""], ["Material", ""]
            ])

            getById("mainTab_View").style.display = "inline-block";
            getById("mainTab").firstChild.classList.add("selectedTab")

            Shaders        = document.Shaders
            Shapes         = document.Shapes
            Engine         = document.Engine
            updateInterval = 30
            previousTime   = 0
            frameNumber    = 0
            engine         = null
            needRestart    = false
            light_marker   = null
            skybox         = getValue("skybox_select")
            params         = {}
        }

        function getAmbiantLightColor(){ return [getValue("ALR"), getValue("ALG"), getValue("ALB")] }
        function getDirLightColor(){ return [getValue("DLR"), getValue("DLG"), getValue("DLB")] }
        function getDirLightPos(){ return [getValue("DLX"), getValue("DLY"), getValue("DLZ")] }
        function getPointLightColor(){ return [getValue("PLR"), getValue("PLG"), getValue("PLB")] }
        function getPointLightPos(){ return [getValue("PLX"), getValue("PLY"), getValue("PLZ")] }
        function getConeLightColor(){ return [getValue("CLR"), getValue("CLG"), getValue("CLB")] }
        function getConeLightPos(){ return [getValue("CLX"), getValue("CLY"), getValue("CLZ")] }
        function getConeLightDir(){ return [getValue("CLDX"), getValue("CLDY"), getValue("CLDZ")] }
        function getDepthFunction(){
            switch(getValue("depth_func")){
                case "NEVER"    : return WebGL2RenderingContext.NEVER 
                case "ALWAYS"   : return WebGL2RenderingContext.ALWAYS 
                case "LESS"     : return WebGL2RenderingContext.LESS 
                case "EQUAL"    : return WebGL2RenderingContext.EQUAL 
                case "LEQUAL"   : return WebGL2RenderingContext.LEQUAL 
                case "GREATER"  : return WebGL2RenderingContext.GREATER 
                case "GEQUAL"   : return WebGL2RenderingContext.GEQUAL 
                case "NOTEQUAL" : return WebGL2RenderingContext.NOTEQUAL 
            }
        }

        function restart(){
            console.log("Restarting...")
            needRestart = true
        }

        function start(){
            needRestart = false
            params.depth_test_function = getDepthFunction()

            const wavefronts = [
                ["Dragon", "dragon/dragon_simple2.obj"]
            ]

            engine = new Engine(getById("canvas"), Shaders.blinnPhongShadowmap, Shaders.shadowMap, params)
            engine.addObject(Shapes.Plane, "Ground")
            //engine.addObject(Shapes.Plane, "WallX", [-10,0,10], [0,90,0])
            //engine.addObject(Shapes.Plane, "WallY", [0,-10,10], [90,0,0])
            /*engine.addObject(Shapes.Cube, "Cube_1", [0,2,1])
            engine.addObject(Shapes.Cube, "Cube_2", [2,0,1])
            engine.addObject(Shapes.Cube, "Cube_3", [0,-2,2])
            engine.addObject(Shapes.Cube, "Cube_4", [-2,0,1])*/
            //ModelHelper.loadWavefront("dragon/dragon.obj", "").then(obj => engine.addObject(obj, "Dragon"))
            //ModelHelper.loadWavefront("gizmo/gizmo.obj", "").then(obj => engine.addObject(obj, "Gizmo"))
            //engine.addObject(Shapes.LightMarker, "Light_marker", [0,0,0])

            ModelHelper.loadWavefronts(wavefronts, engine).then( () => generateObjectsTab(engine.objects.list))

            engine.setCubemap("ressources/cubemaps/"+skybox)
            engine.setSkybox(Shaders.skybox, "ressources/cubemaps/"+skybox)

            generateViewTab(engine)
            generateMaterialTab()
            updateView(true)
            updateMaterial()

            render(0)
        }

        function render(currentTime) {
            frameNumber++
            const deltaTime = currentTime - previousTime
            previousTime = currentTime

            if(frameNumber % updateInterval == 0){
                getById("fps").innerHTML = Math.round(1000/deltaTime)
                getById("refresh_rate").innerHTML = Math.round(deltaTime)+" ms"
            }

            engine.scene.lights.setAmbient(getAmbiantLightColor())
            engine.scene.lights.setDirectional(getDirLightColor(), getDirLightPos())
            engine.scene.lights.setPoint(getPointLightColor(), getPointLightPos())
            engine.scene.lights.setCone(getConeLightColor(), getConeLightPos(), getConeLightDir())
            //engine.setObjectTransform("Light_marker", getConeLightPos())

            engine.render()
            needRestart ? start() : requestAnimationFrame(render)
        }

        function updateView(fromSliders){
            if(fromSliders){
                engine.scene.camera.setView(...getTransformSlidersValues("view"))
                setMatrixValues("view", engine.getViewProjection().view)
            }else{
                const values = getMatrixValues("view")
                console.log(values)
                engine.gl.useProgram(engine.program)
                engine.scene.camera.view = values
                engine.setViewProjection(values)
            }
        }
        function generateViewTab(engine){
            getById("mainTab_View").innerHTML = (
                generateTransformSliders("view", "updateView(true)", [[0,0,-26],[-71,0,-120],[1,1,1]]) +
                "<p>View matrix : </p>"+
                generateMatrix("view", `updateView(false)`, engine.getViewProjection().view) 
            )
        }

        function updateMaterial(){
            const specular = getValue("SpecularFactor")
            const reflection = getValue("ReflectionFactor")
            engine.scene.setMaterial(specular,reflection)
        }
        function generateMaterialTab(){
            getById("mainTab_Material").innerHTML = 
                generateSliders("Specular",   ["Factor"], 0, 5, "Specular",   null, "updateMaterial()") +
                generateSliders("Reflection", ["Factor"], 0, 1, "Reflection", [0.1], "updateMaterial()")
        }

        function updateObject(obj_name, fromSliders){
            const obj_list = Object.values(engine.objects.list)
            if(fromSliders){
                let obj_found = null 
                obj_list.forEach(obj => {
                    if(obj.name == obj_name) {
                        obj_found = obj
                        engine.setObjectTransform(obj_name, ...getTransformSlidersValues(obj_name))
                    }
                })
                setMatrixValues(obj_name, obj_found.modelMatrix)
            }else{
                let values = getMatrixValues(obj_name)
                obj_list.forEach(obj => {
                    if(obj.name == obj_name) {
                        obj.modelMatrix = values
                    }
                })
            }
        }
        function generateObjectsTab(objs){
            let names_content = []
            Object.values(objs).forEach( (obj, i) => {
                let content = `Number of vertices : ${obj.count}<div id="objects_details_${i}_matrix"></div>`
                content += generateTransformSliders(obj.name, `updateObject('${obj.name}', true)`)
                content += "<p>Model matrix :</p>"
                content += generateMatrix(obj.name, `updateObject('${obj.name}', false)`, obj.modelMatrix)
                names_content.push([obj.name, content])
            })
            getById("mainTab_Objects").innerHTML = 
                `<select id="model_selection">
                    <option value="1">Standford Dragon</option> 
                    <option value="2">Utah Teapot</option>
                    <option value="3">Suzanne (blender)</option>  
                    <option value="4">Gizmo</option>  
                </select>
                <button onclick="addModel()">Add</button>
                <hr>` +
                generateTabs("objectsTab", names_content)
        }

        function addModel(){
            const model_id = parseInt(getById("model_selection").value)
            let model = null
            switch (model_id) {
                case 1 :
                    model = ["Dragon", "dragon/dragon_simple2.obj"]
                    break
                case 2 :
                    model = ["Teapot", "teapot/teapot_simple.obj"]
                    break
                case 3 :
                    model = ["Suzanne", "suzanne/suzanne_simple.obj"]
                    break
                case 4 :
                    model = ["Gizmo", "gizmo/gizmo.obj"]
                    break
                default:
                    return
            }
            ModelHelper.loadWavefronts([model], engine).then( () => generateObjectsTab(engine.objects.list))
        }
    </script>  
</html>